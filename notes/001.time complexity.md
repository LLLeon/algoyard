# 算法的复杂度分析

## MISC

所有代码的执行时间 T(n) 和代码行数成正比。

进一步，所有代码的执行时间 T(n) 和每行代码的执行次数成正比。

大 O 时间复杂度表示法公式：T(n) = O(f(n))

T(n) 表示代码的执行时间，n 表示数据规模的大小，f(n) 表示每行代码执行次数的总和。O 表示代码的执行时间 T(n) 与表达式 f(n) 成正比。

大 O 时间复杂度实际并不是代码真正的执行时间，而是代码执行时间随数据规模增长的变化趋势，所以也叫渐近时间复杂度，简称时间复杂度。

当 n 很大时，只需要记录一个最大量级就可以。

## 时间复杂度分析

### 分析的三个方法

1. 只关注循环执行次数最多的一段代码，这段核心代码执行次数 n 的量级，就是整段要分析的代码的时间复杂度。

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度。抽象成公式就是：

   > 如果 T1(n) = O(f(n)), T2(n) = O(g(n)); 那么 T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。公式如下：

   > 如果 T1(n) = O(f(n)), T2(n) = O(g(n)); 那么 T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))

### 复杂度量级

分为多项式量级和非多项式量级。非多项式量级只有两个：O(2n) 和 O(n!)。

把时间复杂度为非多项式量级的算法问题叫做 NP 问题，即非确定多项式问题。随着数据规模的增长，非多项式量级算法的执行时间会急剧增加。

### 多项式时间复杂度

1. 常量阶 O(1)：只是常量级时间复杂度的表示方法，并不是只执行了一行代码。只要代码的执行时间不随 n 的增大而增长，时间复杂度就是 O(1)。一般情况，只要代码中不存在循环、递归语句，不管有多少行代码，其时间复杂度都是 O(1)。

2. 对数阶 O(logn)、O(nlogn)：不管以几为底，把对数阶的时间复杂度都记为 O(logn)。

3. 线性阶 O(m+n)、O(m*n)：前面的加法法则 对于 O(m+n) 不再使用，因为不知道 m 和 n 哪个大，所以公式修改为：

   > T1(m) + T2(n) = O(f(m) + g(n))

### 最好、最坏情况的时间复杂度和平均时间复杂度

最好、最坏的情况比较好理解，比如下面的例子：

```c
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。上面代码中，最好的情况是第一个元素就是要找的元素，那时间复杂度就是 O(1)。

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。上面代码中，如果数组中没有要找的元素就需要把数组全部遍历一遍，那这时时间复杂度就是 O(n)。

但这两种极端情况发生的概率比较小，这时就需要引入平均情况时间复杂度这个概念。

要查找的元素要么在数组中，要么不在，为了理解简便，假设概率各为 1/2；要查找的元素出现在 0~n-1 每个位置的概率都为 1/n，那么出现在每个位置的概率就是 1/2n，于是平均时间复杂度就是：`1*1/2n + 2*1/2n + 3*1/2n + ... + n*1/2n + n*1/2 = (3n+1)/4`，这个值就是概率论中的加权平均值，也叫做期望值，所以平均时间复杂度全称叫做加权平均时间复杂度或期望时间复杂度。这个值用大 O 表示法表示，是 O(n)。

### 均摊时间复杂度

看这段代码：

```c
 // array 表示一个长度为 n 的数组
 // 代码中的 array.length 就等于 n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```

这段代码意思是往数组中插入数据，有两种情况，如果数组中有位置，直接插入；如果没有位置，计算数组中所有元素的和，清空数组，将计算的和放到第一个位置，将要插入的值放到第二个位置。

那么时间复杂度也就有两种，最好情况是 O(1)，最坏情况就是需要遍历计算和的情况，是 O(n)。

这个例子中，每一次 O(n) 操作后都会跟着 n-1 次 O(1) 操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组操作的时间复杂度就是 O(1)。这就是均摊时间复杂度分析的大致思路。

总结一下均摊时间复杂度：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上，而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

## 空间复杂度分析

类比时间复杂度，空间复杂度的全称是渐近空间复杂度，表示算法的存储空间与数据规模之间的增长关系。

