# 链表

链表通过指针将一组零散的内存块串联起来，其中内存块称为链表的节点。为了将所有节点串联起来，每个链表的节点除了存储数据还要记录下一个节点的地址，把这个记录下个节点地址的指针叫做后继指针 next。

链表的种类五花八门，常见的有单链表、双向链表和循环链表等。

## 单链表

单链表的头节点用来记录链表的基地址，尾节点指向 NULL。

链表在插入和删除节点时非常高效，因为不像数组一般还需要移动节点，只需要考虑相邻节点指针的改变，所以时间复杂度是 O(1)。

但是链表想要访问第 K 个元素就没有数组那么高效了，因为链表中数据并不是连续存储的，无法像数组那样通过首地址和下标，通过寻址公式来计算对应的内存地址。而是需要根据指针一个节点一个节点的遍历来找到相应节点。链表随机访问需要 O(n) 的时间复杂度。

## 循环链表

循环链表是一种特殊的单链表，其尾节点的指针不是指向空地址，而是指向头节点。循环链表的优点是从链尾到链头比较方便。

[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)可用循环链表实现。

## 双向链表

双向链表除了后继指针 next 指向后一个节点，还有前驱指针 prev 指向前一个节点。

双向链表可以支持 O(1) 时间复杂度的情况下找到前驱节点，这样的特点使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

当删除给定指针指向的节点时，需要知道其前驱节点，而单链表并不支持直接获取前驱节点，所以，为了找到前驱节点，还是要从头节点开始遍历链表，直到 p->next=q，说明 p 是 q 的前驱节点。但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。针对这种删除，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要O(n) 的时间复杂度。

除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为可以记录上次查找的上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的的应用更加广泛。

双链表就用到了以空间换时间的设计思想。当内存空间充足的时候，如果更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。

## 数组与链表的比较

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

数组的缺点是**大小固定**，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容。

## 基于链表实现 LRU 缓存淘汰算法思路

维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，遍历得到这个数据对应的节点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：
   - 如果此时缓存未满，则将此结点直接插入到链表的头部；
   - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

优化：可以引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。

## 判断一个单链表是不是回文

前提：字符串以单个字符的形式存储在单链表节点中。

1. 遍历链表，判断字符个数是否为奇数，若为偶数，则不是。
2. 最简单的方式，将链表中的字符倒序存储一份在另一个链表中，再同步比较两个链表。但时间复杂度和空间复杂度都是 O(n)，
3. 继续优化，可以用两个指针从两端或者中间遍历并判断对应字符是否相等。但这里的关键就是如何朝两个方向遍历。由于单链表是单向的，所以要向两个方向遍历的话，可以采取经典的快慢指针的方法，使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。时间复杂度是 O(n)，空间复杂度是 O(1)。

## 写链表代码的注意点

1. 指针丢失：插入节点时，一定要注意操作的顺序，比如要将节点 x 插入节点 a 和节点 b 之间，要先将 x.Next 指向节点 b，再将 a.Next 指向节点 x。这样才不会丢失指针，导致内存泄漏。
2. 利用哨兵简化实现难度：针对链表的插入和删除操作，需要对插入第一个节点和删除最后一个节点的情况做特殊处理。这时可以引入哨兵节点，不管链表是否为空，head 指针都指向这个哨兵节点。这种有哨兵的链表叫做带头链表。这样插入第一个节点和插入其它节点，删除最后一个节点和删除其它节点都分别可以统一为相同的代码实现逻辑了。
3. 注意边界条件处理，一般有这几种：
   - 如果链表为空时，代码是否能正常工作？
   - 如果链表只包含一个节点时，代码是否能正常工作？
   - 如果链表只包含两个节点时，代码是否能正常工作？
   - 代码在处理头节点和尾节点时，是否能正常工作？
4. 举例画图：对于稍微复杂的链表操作，可以用举例和画图的方式来辅助思考。

## 链表操作练习

1. 单链表反转。

   思路：利用三个指针 prev、temp、curr 来实现。最开始 prev 为 nil，curr 为 head 节点，开始循环，将 curr 记录到 temp，curr 向后移动一个节点，temp.Next 指向 prev，然后 prev 向后移动到 temp，如此循环即可反转单链表。时间复杂度和空间复杂度分别为 O(n) 和 O(1)。

2. 链表中环的检测。

   最直接的做法，遍历链表，把每个节点存入 map，如果发现重复的节点，即为有环，该重复节点为环的入口。但这样时间复杂度和空间复杂度都是 O(n)。

   优化：可以用快慢指针，慢指针一次移动一个节点，快指针一次移动两个节点。如果没有环，经过一段时间快指针就会到达尾节点；如果有环，两个指针会在某个时刻相遇。当两个指针相遇后，快指针停止移动，慢指针继续移动，当两个指针再次相遇，慢指针走过的节点数目即为环的长度。

3. 两个有序链表的合并。

4. 删除单链表倒数第 n 个节点。

   常规思路：先遍历一遍链表计算出链表长度，然后从单链表头部删除指定的节点。

   优化：使用快慢指针，快指针比慢指针先走 n 个节点，然后两个指针同步向后移动，当快指针移动到尾节点时，慢指针移动到倒数第 n 个节点的前一个节点。

5. 求链表的中间节点。

   可以使用快慢指针。慢指针移动一个节点，快指针移动两个节点，当快指针移动到尾节点时，慢指针移动到中间节点。